### 5.3 RPC编程
>RPC(Remote Procedure Call,远程过程调用)是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络细节的应用程序通信协议。RPC协议构建与TCP或UDP，或者是HTTP之上，允许开发者直接调用另一台计算机上的程序，而开发者无需额外地为这个调用过程编写网络通信相关代码，使得开发包括网络分布式程序在内的应用程序更加容易。

RPC采用**客户端--服务器(Client/Server)**的工作模式。**请求过程**就是一个客户端(Clinet),而服务提供程序就是一个服务器(Server)。当执行一个远程过程调用时，**客户端程序**首先发送一个带有参数的调用信息到服务端，然后等待服务端响应。在**服务端**，服务进程保持睡眠状态直到客户端的调用信息到达为止。当一个调用信息到达时，服务端**获得进程参数**，**计算出结果**，并向客户端**发送应答信息**，然后**等待下一个调用**。最后，客户端**接收来自服务端的应答信息**，**获得进程结果**，然后调用执行并继续进行。

#### 5.3.1 Go语言中的RPC支持与处理
在Go中，标准库提供的`net/rpc`包实现了RPC协议需要的相关细节，开发者可以很方便地使用该包编写RPC的服务端和客户端程序，这使得用Go语言开发的多个进程之间的通信变得非常简单。

`net/rpc`包允许RPC客户端程序通过网络或是其他I/O连接调用一个远端对象的公开方法(必须是大写字母开头、可外部调用的)。在RPC服务端，可将一个对象注册为客访问的服务，之后该对象的公开方法就能够以远程的方式提供访问。一个RPC服务端可以注册多个不同类型的对象，但不允许注册同一类型的多个对象。

一个对象中只有满足如下这些条件的方法，才能被RPC服务端设置为可供远程访问：
* 必须是在对象外部可公开调用的方法(首字母大写)
* 必须有两个参数，且参数的类型都必须是包外部可以访问的类型或者是Go内建支持的类型
* 第二个参数必须是一个指针
* 方法必须返回一个error类型的值
以上4个条件，可以简单地用如下一行代码表示：
```go
func(t *T) MethodName(argType T1,replyType *T2) error
```
在上面这行代码中，类型T、T1和T2默认会使用Go内置的`encoding/gob`包(稍后介绍)进行编码解码。

该方法(MethodName)的第一个参数表示由RPC客户端传入的参数，第二个参数表示要返回给RPC客户端的结果，该方法最后返回一个error类型的值。

RPC服务端可以通过调用`rpc.ServeConn`处理单个连接请求。多数情况下，通过TCP或是HTTP在某个网络地址上进行监听来创建该服务是个不错的选择。

在RPC客户端，Go的`net/rpc`包提供了便利的`rpc.Dial()`和`rpc.DialHTTP()`方法来与指定的RPC服务端建立连接。

在建立连接之后，Go的`net/rpc`包允许我们使用同步或者异步的方式接收RPC服务端的处理结果。调用RPC客户端的**`Call()`**方法则进行**同步处理**,这时候客户端程序安顺序执行，只有接受完RPC服务端的处理结果之后才可以继续执行后面的程序。当调用RPC客户端的**`Go()`**方法时，则可以进行**异步处理**，RPC客户端程序无需等待服务端的结果即可执行后面的程序，而当接收到RPC服务端的处理结果时，再对其进行相应的处理。

无论是调用RPC客户端的`Call()`或者是`Go()`方法，都必须指定要调用的服务及其方法名称，以及一个客户端传入参数的引用，还有一个用于接收处理结果参数的指针。

如果没有明确指定RPC传输过程中使用何种编码解码器，默认将使用Go标准库提供的`encoding/gob`包进行数据传输。
[RPC服务端和客户端交互的示例程序](www.baidu.com)