###2.3 类型
Go语言内置以下这些**基础类型**
* 布尔类型：`bool`
* 整型：`int8`、`byte`、`int16`、`int`、`uint`、`uintptr`等。
* 浮点类型：`float32`、`float64`
* 复数类型：`complex64`、`complex128`
* 字符串：`string`
* 字符类型：`rune`
* 错误类型：`error` 详情见2.6
Go语言也支持以下这些**复合类型**:
* 指针：`pointer`
* 数组：`array`
* 切片：`slice`
* 字典：`map`
* 通道：`chan` 详情见4.5
* 结构体：`struct`
* 接口：`interface`详情见3.5

**在这些基础类型之上Go还封装了`int`、`uint`和`uintptr`等，这些类型的特点在于使用方便，但使用者不能对这些类型的长度坐任何假设。对于常规的开发来说，用`int`和`uint`就可以了，没必要用`int8`之类明确指定长度的类型，以免导致移植困难。**

###2.3.1 布尔类型
>关键字为`bool`，可赋值为预定义的`true`和`false`
```go
var v1 bool
v1 = true
v2 := (1 == 2) //v2也会被推导为bool类型

/**
布尔类型不能接受其他类型的赋值
不支持自动或强制的类型转换
*/
var b bool
b = 1       //编译错误
b = bool(1) //编译错误

var c bool
c = (1 != 0) //编译正确
```
###2.3.2 整型
| 类型           | 长度(字节) | 值范围 |
| ------------- |-----------| ---------|
| int8          |     1     | -128~127 |
| uint8(即byte) |     1     | 0~255|
| int16         |     2     | -32768~32767 |
| uint16        |     2     | 0~65535 |
| int32         |     4     | -2147483648~2147483647 |
| uint32        |     4     | 0~4294967295 |
| int64 		| 	  8     |    -9223372036854775808~9223372036854775807 |
| uint64 		| 	  8     | 0~18446744073709551615 |
| int 		    | 平台相关   |    平台相关 |
| uint		    | 平台相关   |    平台相关 |
| uintprt	    | 同指针     |  在32位平台下位4字节，64位平台下位8字节 |

######1.类型表示
**int和int32在Go语言里被认为是两种不同的类型，编译器也不会自动做类型转换。如必要，需做强制类型转换，注意数据长度被截短而发生的数据精度损失(比如将浮点数强制转为整数)和值溢出(值超过转换的目标类型的值范围)问题**

######2.数值运算
>Go语言支持：+、-、*、/和%

######3.比较运算
>Go语言支持：>、<、==、>=、<=、!=
**两个不同类型的整型数不能直接比较，但个中类型的整型变量都可以直接与字面常量（literal）进行比较 

######4.位运算
|运算|含义|样例|
|------|------|
|x<<y|左移|124<<2 //结果为496
|x>>y|右移|124>>2//结果为31
|x^y|异或 |124^2//结果为126
|x&y| 与  |124&2//结果为0
| x\|y| 或|124\|2//结果为126
|^x|取反|^2//结果为-3

###2.3.3 浮点型
>浮点型用语表示包含小数点的数据，Go中采用IEEE-754标准的表达方式
######1.浮点数表示
>Go语言定义了两个类型`float32`和`float64`
```go
var fvalue1 float32
fvalue1 = 12

/**
会被自动设为float64，而不管赋给它的数字是否是用32位长度表示的
如果不加小数点，fvalue2会被推导为整型而不是浮点型
*/
fvalue2 := 12.0

fvalue1 = fvalue2 //编译错误，类型不同
fvalue1 = float32(fvalue2)//编译正确，强转
```
######2.浮点数比较
>因为浮点数不是一种精确的表达方式,不能用`==`来比较,会导致结果不稳定.
```go
import "math"

//p为用户自定义的比较精度,比如0.0001
func IsEqual(f1, f2 float64) bool {
	return math.Abs(f1, f2) < p
}
```
###2.3.4 复数类型
>复数实际上由两个实数（在计算机中用浮点数表示）构成，一个表示实部（real），一个表示虚部（imag）。
######1.复数表示
```go
var value1 complex64	//由两个float32构成的复数类型
value1=3.2+12i
value2:=3.2+12i			//value2是complex128类型
value3:=complex(3.2,12) //value3结果同value2
```
######2.实部与虚部
>对于一个复数`z = complex(x ,  y)`,就可以通过Go语言内置函数`real(z)`获得该复数的实部，也就是x；通过`imag(z)`获得该复数的虚部，也就是y。

详情请见`math/coplx`标准库的文档

###2.3.5 字符串
>在Go语言中，字符串也是一种基本类型。